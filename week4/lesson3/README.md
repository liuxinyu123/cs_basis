# 第三讲    
## 浮点运算及结果    
* 设两个规格化浮点数分别为A=Ma * 2^Ea, B=Mb * 2^Eb,则   
> A + B = (A + B * 2^(Eb-Ea)) * 2^Ea   (Ea > Eb)  减法类似    
> A * B = Ma * Mb * 2^(Ea+Eb)     
> A / B = Ma/Mb * 2^(Ea-Eb)    

* 上述运算可能出现如下几种情况    
> - 阶码上溢：一个正指数超过最大允许值   (32位最大允许值为127)     
> - 阶码下溢：一个负指数超过最小允许值   (32位最小允许值为-126)
> - 尾数溢出：最高有效位有进位，进行右规(尾数右移，阶码加相应值)   
> - 非规格化尾数：尾数数值部分最高位为0，进行左规(尾数左移，阶码减相应值)     
> > 右规或者对阶时，因为尾数舍入，右段有效位丢失，解决办法是在运算过程中添加**保护位**，在运算过程中保留这些溢出位，直到最后给出运算结果时，才进行舍入。      

### IEEE 754规定的五种异常情况   
1. 无效运算    
> - 运算时有一个数是非有限值  比如 加减一个∞  ，0 * ∞ ，∞／∞     
> - 结果无效    源操作数是NaN， 0/0， x%0, ∞%y      

2. 除以0 (结果为无穷大)
3. 数太大，阶码上溢(超过127)    
4. 数太小，阶码下溢(低于-126)   
5. 结果不精确(舍入时引起)  例如1/3,1/10不能精确表示成浮点数   
> 上述情况硬件可以捕捉到，因此这些异常可以让硬件来处理，也可以让软件来处理。让硬件处理时，称为硬件陷阱。      

### 浮点数加减运算   
> 进行尾数加减操作前，必须**对阶**，还要考虑舍入问题  
* 对阶操作 (目的是使两个数的阶码相等)    
> - 小阶向大阶看齐， 阶小的那个数的尾码右移，右移尾数等于两个阶码差的绝对值    
> - IEEE 754规定尾数右移时，要将*隐含的1*移到小数部分，高位补0， 移出的低位保留到特定的**附加位**     

#### 附加位    
> 浮点数就像一堆沙，每动一次就会失去一点"沙", 并拣回一点"脏"     
* 如何才能使失去的"沙"和拣回的"脏"尽量少呢    
> 在后面添加附加位    可是多少位附加位合适呢?    
> > 无法确定   
> IEEE 754规定：中间结果需要在后面添加2个附加位   
> > - 保护位   
> > - 舍入位    

#### 舍入位  
* IEEE的四种舍入方式   
> - 就近舍入  (默认) 精度最高    
> - 向整无穷舍入   
> - 向负无穷舍入   
> - 向0舍入    

> 就近舍入的方式   
> - 舍入位<1/2  截断丢弃   
> - 舍入位>1/2  末位加1   
> - 舍入位=1/2  取最近的偶数     

### C语言中的浮点数类型   
* C语言中有float和double类型，分别对应IEEE 754中的单精度和双精度浮点数格式，与具体的高级语言无关    
* long double类型的长度和格式随编译器和处理器的不同而不同    
* 从int到float的转换不会发生溢出，但可能会有数据被舍入   
> 因为float类型表示的数的范围比int的大，但是int的数据位是31位表示，float的尾数部分是23+1位表示      

* 从int或float到double的转换，能够保留精确值，double的尾数位是52+1位表示    
* 从double到int或float的转换，可能发生溢出，此外，由于有效位数变少，故可能被舍入    
* 从float或double到int的转换，因为int没有小数部分，所以数据可能会向0方向被截断   

#### 浮点数的结合律不正确  
